(self["webpackChunkfinal_project"] = self["webpackChunkfinal_project"] || []).push([["vendors-node_modules_formspree_react_dist_index_mjs"],{

/***/ "./node_modules/@formspree/core/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@formspree/core/dist/index.js ***!
  \****************************************************/
/***/ ((module) => {

var E=Object.defineProperty,Y=Object.defineProperties,k=Object.getOwnPropertyDescriptor,K=Object.getOwnPropertyDescriptors,$=Object.getOwnPropertyNames,O=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var C=(e,t,r)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,S=(e,t)=>{for(var r in t||(t={}))P.call(t,r)&&C(e,r,t[r]);if(O)for(var r of O(t))z.call(t,r)&&C(e,r,t[r]);return e},g=(e,t)=>Y(e,K(t));var J=(e,t)=>{for(var r in t)E(e,r,{get:t[r],enumerable:!0})},q=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of $(t))!P.call(e,i)&&i!==r&&E(e,i,{get:()=>t[i],enumerable:!(o=k(t,i))||o.enumerable});return e};var G=e=>q(E({},"__esModule",{value:!0}),e);var R=(e,t,r)=>new Promise((o,i)=>{var s=p=>{try{n(r.next(p))}catch(c){i(c)}},a=p=>{try{n(r.throw(p))}catch(c){i(c)}},n=p=>p.done?o(p.value):Promise.resolve(p.value).then(s,a);n((r=r.apply(e,t)).next())});var Z={};J(Z,{Client:()=>b,createClient:()=>x,getDefaultClient:()=>U,isFieldError:()=>M});module.exports=G(Z);var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",H=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;function w(e){e=String(e);for(var t,r,o,i,s="",a=0,n=e.length%3;a<e.length;){if((r=e.charCodeAt(a++))>255||(o=e.charCodeAt(a++))>255||(i=e.charCodeAt(a++))>255)throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");t=r<<16|o<<8|i,s+=m.charAt(t>>18&63)+m.charAt(t>>12&63)+m.charAt(t>>6&63)+m.charAt(t&63)}return n?s.slice(0,n-3)+"===".substring(n):s}function F(e){if(e=String(e).replace(/[\t\n\f\r ]+/g,""),!H.test(e))throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");e+="==".slice(2-(e.length&3));for(var t,r="",o,i,s=0;s<e.length;)t=m.indexOf(e.charAt(s++))<<18|m.indexOf(e.charAt(s++))<<12|(o=m.indexOf(e.charAt(s++)))<<6|(i=m.indexOf(e.charAt(s++))),r+=o===64?String.fromCharCode(t>>16&255):i===64?String.fromCharCode(t>>16&255,t>>8&255):String.fromCharCode(t>>16&255,t>>8&255,t&255);return r}var A="2.8.3";var D=(s=>(s.REQUIRED_FIELD_MISSING="REQUIRED_FIELD_MISSING",s.REQUIRED_FIELD_EMPTY="REQUIRED_FIELD_EMPTY",s.TYPE_EMAIL="TYPE_EMAIL",s.TYPE_NUMERIC="TYPE_NUMERIC",s.TYPE_TEXT="TYPE_TEXT",s))(D||{});function M(e){return e.code in D&&e.field!==void 0}function N(e){return e.errors!==void 0}var j=e=>w(JSON.stringify(e));var L=e=>{let t=`@formspree/core@${A}`;return e?`${e} ${t}`:t},v=()=>1*new Date,h=(e,t,r)=>{e instanceof FormData?e.append(t,r):e=Object.assign(e,{[t]:r})},B=p=>R(void 0,[p],function*({stripePromise:e,response:t,responseData:r,payload:o,data:i,fetchImpl:s,request:a,url:n}){let c=yield e.handleCardAction(r.stripe.paymentIntentClientSecret);if(c.error)return{response:t,body:{errors:[{code:"STRIPE_CLIENT_ERROR",message:"Stripe SCA error",field:"paymentMethod"}]}};{o.paymentMethod.id||h(i,"paymentMethod",o.paymentMethod.id),h(i,"paymentIntent",c.paymentIntent.id),h(i,"resubmitKey",r.resubmitKey);let l=yield s(n,g(S({},a),{body:JSON.stringify({paymentIntent:c.paymentIntent.id,resubmitKey:r.resubmitKey})})),u=yield l.json();return{response:l,body:u}}});function _({body:e,response:t}){return!N(e)&&(e!=null&&e.error)&&(e={errors:[{message:e.error}]}),{body:e,response:t}}var V=()=>navigator.webdriver||!!document.documentElement.getAttribute(F("d2ViZHJpdmVy"))||!!window.callPhantom||!!window._phantom,I=class{constructor(){this.loadedAt=v(),this.webdriver=V()}teardown(){}data(){return{loadedAt:this.loadedAt,webdriver:this.webdriver}}};var b=class{constructor(t={}){this.project=t.project,this.stripePromise=t.stripePromise,typeof window!="undefined"&&this.startBrowserSession()}startBrowserSession(){this.session||(this.session=new I)}teardown(){this.session&&this.session.teardown()}submitForm(i,s){return R(this,arguments,function*(t,r,o={}){let a=o.endpoint||"https://formspree.io",n=o.fetchImpl||fetch,p=this.project?`${a}/p/${this.project}/f/${t}`:`${a}/f/${t}`,c=d=>d instanceof FormData?d:JSON.stringify(d),l={Accept:"application/json","Formspree-Client":L(o.clientName)};this.session&&(l["Formspree-Session-Data"]=j(this.session.data())),r instanceof FormData||(l["Content-Type"]="application/json");let u={method:"POST",mode:"cors",body:c(r),headers:l};if(this.stripePromise&&o.createPaymentMethod){let d=yield o.createPaymentMethod();if(d.error)return{response:null,body:{errors:[{code:"STRIPE_CLIENT_ERROR",message:"Error creating payment method",field:"paymentMethod"}]}};h(r,"paymentMethod",d.paymentMethod.id);let y=yield n(p,g(S({},u),{body:r})),f=yield y.json();return f&&f.stripe&&f.stripe.requiresAction&&f.resubmitKey?yield B({stripePromise:this.stripePromise,responseData:f,response:y,payload:d,data:r,fetchImpl:n,request:u,url:p}):_({response:y,body:f})}else return n(p,u).then(d=>d.json().then(y=>_({body:y,response:d}))).catch()})}},x=e=>new b(e),U=()=>(T||(T=x()),T),T;0&&(0);


/***/ }),

/***/ "./node_modules/@stripe/react-stripe-js/dist/react-stripe.umd.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.umd.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! react */ "./node_modules/react/index.js")) :
  0;
}(this, (function (exports, React) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  function emptyFunction() {}

  function emptyFunctionWithReset() {}

  emptyFunctionWithReset.resetWarningCache = emptyFunction;

  var factoryWithThrowingShims = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret_1) {
        // It is still safe when called from React.
        return;
      }

      var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
      err.name = 'Invariant Violation';
      throw err;
    }
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = factoryWithThrowingShims();
  }
  });

  var usePrevious = function usePrevious(value) {
    var ref = React.useRef(value);
    React.useEffect(function () {
      ref.current = value;
    }, [value]);
    return ref.current;
  };

  var isUnknownObject = function isUnknownObject(raw) {
    return raw !== null && _typeof(raw) === 'object';
  };
  var isPromise = function isPromise(raw) {
    return isUnknownObject(raw) && typeof raw.then === 'function';
  }; // We are using types to enforce the `stripe` prop in this lib,
  // but in an untyped integration `stripe` could be anything, so we need
  // to do some sanity validation to prevent type errors.

  var isStripe = function isStripe(raw) {
    return isUnknownObject(raw) && typeof raw.elements === 'function' && typeof raw.createToken === 'function' && typeof raw.createPaymentMethod === 'function' && typeof raw.confirmCardPayment === 'function';
  };

  var PLAIN_OBJECT_STR = '[object Object]';
  var isEqual = function isEqual(left, right) {
    if (!isUnknownObject(left) || !isUnknownObject(right)) {
      return left === right;
    }

    var leftArray = Array.isArray(left);
    var rightArray = Array.isArray(right);
    if (leftArray !== rightArray) return false;
    var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;
    var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;
    if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so
    // fallback to reference check.

    if (!leftPlainObject && !leftArray) return left === right;
    var leftKeys = Object.keys(left);
    var rightKeys = Object.keys(right);
    if (leftKeys.length !== rightKeys.length) return false;
    var keySet = {};

    for (var i = 0; i < leftKeys.length; i += 1) {
      keySet[leftKeys[i]] = true;
    }

    for (var _i = 0; _i < rightKeys.length; _i += 1) {
      keySet[rightKeys[_i]] = true;
    }

    var allKeys = Object.keys(keySet);

    if (allKeys.length !== leftKeys.length) {
      return false;
    }

    var l = left;
    var r = right;

    var pred = function pred(key) {
      return isEqual(l[key], r[key]);
    };

    return allKeys.every(pred);
  };

  var extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {
    if (!isUnknownObject(options)) {
      return null;
    }

    return Object.keys(options).reduce(function (newOptions, key) {
      var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);

      if (immutableKeys.includes(key)) {
        if (isUpdated) {
          console.warn("Unsupported prop change: options.".concat(key, " is not a mutable property."));
        }

        return newOptions;
      }

      if (!isUpdated) {
        return newOptions;
      }

      return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));
    }, null);
  };

  var INVALID_STRIPE_ERROR = 'Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.'; // We are using types to enforce the `stripe` prop in this lib, but in a real
  // integration `stripe` could be anything, so we need to do some sanity
  // validation to prevent type errors.

  var validateStripe = function validateStripe(maybeStripe) {
    if (maybeStripe === null || isStripe(maybeStripe)) {
      return maybeStripe;
    }

    throw new Error(INVALID_STRIPE_ERROR);
  };

  var parseStripeProp = function parseStripeProp(raw) {
    if (isPromise(raw)) {
      return {
        tag: 'async',
        stripePromise: Promise.resolve(raw).then(validateStripe)
      };
    }

    var stripe = validateStripe(raw);

    if (stripe === null) {
      return {
        tag: 'empty'
      };
    }

    return {
      tag: 'sync',
      stripe: stripe
    };
  };

  var ElementsContext = /*#__PURE__*/React.createContext(null);
  ElementsContext.displayName = 'ElementsContext';
  var parseElementsContext = function parseElementsContext(ctx, useCase) {
    if (!ctx) {
      throw new Error("Could not find Elements context; You need to wrap the part of your app that ".concat(useCase, " in an <Elements> provider."));
    }

    return ctx;
  };
  var CartElementContext = /*#__PURE__*/React.createContext(null);
  CartElementContext.displayName = 'CartElementContext';
  var parseCartElementContext = function parseCartElementContext(ctx, useCase) {
    if (!ctx) {
      throw new Error("Could not find Elements context; You need to wrap the part of your app that ".concat(useCase, " in an <Elements> provider."));
    }

    return ctx;
  };
  /**
   * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.
   * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.
   *
   * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.
   * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.
   * Pass the returned `Promise` to `Elements`.
   *
   * @docs https://stripe.com/docs/stripe-js/react#elements-provider
   */

  var Elements = function Elements(_ref) {
    var rawStripeProp = _ref.stripe,
        options = _ref.options,
        children = _ref.children;
    var parsed = React.useMemo(function () {
      return parseStripeProp(rawStripeProp);
    }, [rawStripeProp]);

    var _React$useState = React.useState(null),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        cart = _React$useState2[0],
        setCart = _React$useState2[1];

    var _React$useState3 = React.useState(null),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        cartState = _React$useState4[0],
        setCartState = _React$useState4[1]; // For a sync stripe instance, initialize into context


    var _React$useState5 = React.useState(function () {
      return {
        stripe: parsed.tag === 'sync' ? parsed.stripe : null,
        elements: parsed.tag === 'sync' ? parsed.stripe.elements(options) : null
      };
    }),
        _React$useState6 = _slicedToArray(_React$useState5, 2),
        ctx = _React$useState6[0],
        setContext = _React$useState6[1];

    React.useEffect(function () {
      var isMounted = true;

      var safeSetContext = function safeSetContext(stripe) {
        setContext(function (ctx) {
          // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)
          if (ctx.stripe) return ctx;
          return {
            stripe: stripe,
            elements: stripe.elements(options)
          };
        });
      }; // For an async stripePromise, store it in context once resolved


      if (parsed.tag === 'async' && !ctx.stripe) {
        parsed.stripePromise.then(function (stripe) {
          if (stripe && isMounted) {
            // Only update Elements context if the component is still mounted
            // and stripe is not null. We allow stripe to be null to make
            // handling SSR easier.
            safeSetContext(stripe);
          }
        });
      } else if (parsed.tag === 'sync' && !ctx.stripe) {
        // Or, handle a sync stripe instance going from null -> populated
        safeSetContext(parsed.stripe);
      }

      return function () {
        isMounted = false;
      };
    }, [parsed, ctx, options]); // Warn on changes to stripe prop

    var prevStripe = usePrevious(rawStripeProp);
    React.useEffect(function () {
      if (prevStripe !== null && prevStripe !== rawStripeProp) {
        console.warn('Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.');
      }
    }, [prevStripe, rawStripeProp]); // Apply updates to elements when options prop has relevant changes

    var prevOptions = usePrevious(options);
    React.useEffect(function () {
      if (!ctx.elements) {
        return;
      }

      var updates = extractAllowedOptionsUpdates(options, prevOptions, ['clientSecret', 'fonts']);

      if (updates) {
        ctx.elements.update(updates);
      }
    }, [options, prevOptions, ctx.elements]); // Attach react-stripe-js version to stripe.js instance

    React.useEffect(function () {
      var anyStripe = ctx.stripe;

      if (!anyStripe || !anyStripe._registerWrapper || !anyStripe.registerAppInfo) {
        return;
      }

      anyStripe._registerWrapper({
        name: 'react-stripe-js',
        version: "1.16.5"
      });

      anyStripe.registerAppInfo({
        name: 'react-stripe-js',
        version: "1.16.5",
        url: 'https://stripe.com/docs/stripe-js/react'
      });
    }, [ctx.stripe]);
    return /*#__PURE__*/React.createElement(ElementsContext.Provider, {
      value: ctx
    }, /*#__PURE__*/React.createElement(CartElementContext.Provider, {
      value: {
        cart: cart,
        setCart: setCart,
        cartState: cartState,
        setCartState: setCartState
      }
    }, children));
  };
  Elements.propTypes = {
    stripe: propTypes.any,
    options: propTypes.object
  };
  var useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {
    var ctx = React.useContext(ElementsContext);
    return parseElementsContext(ctx, useCaseMessage);
  };
  var useCartElementContextWithUseCase = function useCartElementContextWithUseCase(useCaseMessage) {
    var ctx = React.useContext(CartElementContext);
    return parseCartElementContext(ctx, useCaseMessage);
  };
  /**
   * @docs https://stripe.com/docs/stripe-js/react#useelements-hook
   */

  var useElements = function useElements() {
    var _useElementsContextWi = useElementsContextWithUseCase('calls useElements()'),
        elements = _useElementsContextWi.elements;

    return elements;
  };
  /**
   * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook
   */

  var useStripe = function useStripe() {
    var _useElementsContextWi2 = useElementsContextWithUseCase('calls useStripe()'),
        stripe = _useElementsContextWi2.stripe;

    return stripe;
  };
  /**
   * @docs https://stripe.com/docs/payments/checkout/cart-element
   */

  var useCartElement = function useCartElement() {
    var _useCartElementContex = useCartElementContextWithUseCase('calls useCartElement()'),
        cart = _useCartElementContex.cart;

    return cart;
  };
  /**
   * @docs https://stripe.com/docs/payments/checkout/cart-element
   */

  var useCartElementState = function useCartElementState() {
    var _useCartElementContex2 = useCartElementContextWithUseCase('calls useCartElementState()'),
        cartState = _useCartElementContex2.cartState;

    return cartState;
  };
  /**
   * @docs https://stripe.com/docs/stripe-js/react#elements-consumer
   */

  var ElementsConsumer = function ElementsConsumer(_ref2) {
    var children = _ref2.children;
    var ctx = useElementsContextWithUseCase('mounts <ElementsConsumer>'); // Assert to satisfy the busted React.FC return type (it should be ReactNode)

    return children(ctx);
  };
  ElementsConsumer.propTypes = {
    children: propTypes.func.isRequired
  };

  var useAttachEvent = function useAttachEvent(element, event, cb) {
    var cbDefined = !!cb;
    var cbRef = React.useRef(cb); // In many integrations the callback prop changes on each render.
    // Using a ref saves us from calling element.on/.off every render.

    React.useEffect(function () {
      cbRef.current = cb;
    }, [cb]);
    React.useEffect(function () {
      if (!cbDefined || !element) {
        return function () {};
      }

      var decoratedCb = function decoratedCb() {
        if (cbRef.current) {
          cbRef.current.apply(cbRef, arguments);
        }
      };

      element.on(event, decoratedCb);
      return function () {
        element.off(event, decoratedCb);
      };
    }, [cbDefined, event, element, cbRef]);
  };

  var capitalized = function capitalized(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  var createElementComponent = function createElementComponent(type, isServer) {
    var displayName = "".concat(capitalized(type), "Element");

    var ClientElement = function ClientElement(_ref) {
      var id = _ref.id,
          className = _ref.className,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          onBlur = _ref.onBlur,
          onFocus = _ref.onFocus,
          onReady = _ref.onReady,
          onChange = _ref.onChange,
          onEscape = _ref.onEscape,
          onClick = _ref.onClick,
          onLoadError = _ref.onLoadError,
          onLoaderStart = _ref.onLoaderStart,
          onNetworksChange = _ref.onNetworksChange,
          onCheckout = _ref.onCheckout,
          onLineItemClick = _ref.onLineItemClick,
          onConfirm = _ref.onConfirm,
          onCancel = _ref.onCancel,
          onShippingAddressChange = _ref.onShippingAddressChange,
          onShippingRateChange = _ref.onShippingRateChange;

      var _useElementsContextWi = useElementsContextWithUseCase("mounts <".concat(displayName, ">")),
          elements = _useElementsContextWi.elements;

      var _React$useState = React.useState(null),
          _React$useState2 = _slicedToArray(_React$useState, 2),
          element = _React$useState2[0],
          setElement = _React$useState2[1];

      var elementRef = React.useRef(null);
      var domNode = React.useRef(null);

      var _useCartElementContex = useCartElementContextWithUseCase("mounts <".concat(displayName, ">")),
          setCart = _useCartElementContex.setCart,
          setCartState = _useCartElementContex.setCartState; // For every event where the merchant provides a callback, call element.on
      // with that callback. If the merchant ever changes the callback, removes
      // the old callback with element.off and then call element.on with the new one.


      useAttachEvent(element, 'blur', onBlur);
      useAttachEvent(element, 'focus', onFocus);
      useAttachEvent(element, 'escape', onEscape);
      useAttachEvent(element, 'click', onClick);
      useAttachEvent(element, 'loaderror', onLoadError);
      useAttachEvent(element, 'loaderstart', onLoaderStart);
      useAttachEvent(element, 'networkschange', onNetworksChange);
      useAttachEvent(element, 'lineitemclick', onLineItemClick);
      useAttachEvent(element, 'confirm', onConfirm);
      useAttachEvent(element, 'cancel', onCancel);
      useAttachEvent(element, 'shippingaddresschange', onShippingAddressChange);
      useAttachEvent(element, 'shippingratechange', onShippingRateChange);
      var readyCallback;

      if (type === 'cart') {
        readyCallback = function readyCallback(event) {
          setCartState(event);
          onReady && onReady(event);
        };
      } else if (onReady) {
        if (type === 'payButton') {
          // Passes through the event, which includes visible PM types
          readyCallback = onReady;
        } else {
          // For other Elements, pass through the Element itself.
          readyCallback = function readyCallback() {
            onReady(element);
          };
        }
      }

      useAttachEvent(element, 'ready', readyCallback);
      var changeCallback = type === 'cart' ? function (event) {
        setCartState(event);
        onChange && onChange(event);
      } : onChange;
      useAttachEvent(element, 'change', changeCallback);
      var checkoutCallback = type === 'cart' ? function (event) {
        setCartState(event);
        onCheckout && onCheckout(event);
      } : onCheckout;
      useAttachEvent(element, 'checkout', checkoutCallback);
      React.useLayoutEffect(function () {
        if (elementRef.current === null && elements && domNode.current !== null) {
          var newElement = elements.create(type, options);

          if (type === 'cart' && setCart) {
            // we know that elements.create return value must be of type StripeCartElement if type is 'cart',
            // we need to cast because typescript is not able to infer which overloaded method is used based off param type
            setCart(newElement);
          } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode


          elementRef.current = newElement; // Store element in state to facilitate event listener attachment

          setElement(newElement);
          newElement.mount(domNode.current);
        }
      }, [elements, options, setCart]);
      var prevOptions = usePrevious(options);
      React.useEffect(function () {
        if (!elementRef.current) {
          return;
        }

        var updates = extractAllowedOptionsUpdates(options, prevOptions, ['paymentRequest']);

        if (updates) {
          elementRef.current.update(updates);
        }
      }, [options, prevOptions]);
      React.useLayoutEffect(function () {
        return function () {
          if (elementRef.current) {
            elementRef.current.destroy();
            elementRef.current = null;
          }
        };
      }, []);
      return /*#__PURE__*/React.createElement("div", {
        id: id,
        className: className,
        ref: domNode
      });
    }; // Only render the Element wrapper in a server environment.


    var ServerElement = function ServerElement(props) {
      // Validate that we are in the right context by calling useElementsContextWithUseCase.
      useElementsContextWithUseCase("mounts <".concat(displayName, ">"));
      useCartElementContextWithUseCase("mounts <".concat(displayName, ">"));
      var id = props.id,
          className = props.className;
      return /*#__PURE__*/React.createElement("div", {
        id: id,
        className: className
      });
    };

    var Element = isServer ? ServerElement : ClientElement;
    Element.propTypes = {
      id: propTypes.string,
      className: propTypes.string,
      onChange: propTypes.func,
      onBlur: propTypes.func,
      onFocus: propTypes.func,
      onReady: propTypes.func,
      onEscape: propTypes.func,
      onClick: propTypes.func,
      onLoadError: propTypes.func,
      onLoaderStart: propTypes.func,
      onNetworksChange: propTypes.func,
      onCheckout: propTypes.func,
      onLineItemClick: propTypes.func,
      onConfirm: propTypes.func,
      onCancel: propTypes.func,
      onShippingAddressChange: propTypes.func,
      onShippingRateChange: propTypes.func,
      options: propTypes.object
    };
    Element.displayName = displayName;
    Element.__elementType = type;
    return Element;
  };

  var isServer = typeof window === 'undefined';
  /**
   * Requires beta access:
   * Contact [Stripe support](https://support.stripe.com/) for more information.
   *
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var AuBankAccountElement = createElementComponent('auBankAccount', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var CardElement = createElementComponent('card', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var CardNumberElement = createElementComponent('cardNumber', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var CardExpiryElement = createElementComponent('cardExpiry', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var CardCvcElement = createElementComponent('cardCvc', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var FpxBankElement = createElementComponent('fpxBank', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var IbanElement = createElementComponent('iban', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var IdealBankElement = createElementComponent('idealBank', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var P24BankElement = createElementComponent('p24Bank', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var EpsBankElement = createElementComponent('epsBank', isServer);
  var PaymentElement = createElementComponent('payment', isServer);
  /**
   * Requires beta access:
   * Contact [Stripe support](https://support.stripe.com/) for more information.
   *
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var PayButtonElement = createElementComponent('payButton', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var PaymentRequestButtonElement = createElementComponent('paymentRequestButton', isServer);
  /**
   * Requires beta access:
   * Contact [Stripe support](https://support.stripe.com/) for more information.
   *
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var LinkAuthenticationElement = createElementComponent('linkAuthentication', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var AddressElement = createElementComponent('address', isServer);
  /**
   * @deprecated
   * Use `AddressElement` instead.
   *
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var ShippingAddressElement = createElementComponent('shippingAddress', isServer);
  /**
   * Requires beta access:
   * Contact [Stripe support](https://support.stripe.com/) for more information.
   *
   * @docs https://stripe.com/docs/elements/cart-element
   */

  var CartElement = createElementComponent('cart', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var PaymentMethodMessagingElement = createElementComponent('paymentMethodMessaging', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var AffirmMessageElement = createElementComponent('affirmMessage', isServer);
  /**
   * @docs https://stripe.com/docs/stripe-js/react#element-components
   */

  var AfterpayClearpayMessageElement = createElementComponent('afterpayClearpayMessage', isServer);

  exports.AddressElement = AddressElement;
  exports.AffirmMessageElement = AffirmMessageElement;
  exports.AfterpayClearpayMessageElement = AfterpayClearpayMessageElement;
  exports.AuBankAccountElement = AuBankAccountElement;
  exports.CardCvcElement = CardCvcElement;
  exports.CardElement = CardElement;
  exports.CardExpiryElement = CardExpiryElement;
  exports.CardNumberElement = CardNumberElement;
  exports.CartElement = CartElement;
  exports.Elements = Elements;
  exports.ElementsConsumer = ElementsConsumer;
  exports.EpsBankElement = EpsBankElement;
  exports.FpxBankElement = FpxBankElement;
  exports.IbanElement = IbanElement;
  exports.IdealBankElement = IdealBankElement;
  exports.LinkAuthenticationElement = LinkAuthenticationElement;
  exports.P24BankElement = P24BankElement;
  exports.PayButtonElement = PayButtonElement;
  exports.PaymentElement = PaymentElement;
  exports.PaymentMethodMessagingElement = PaymentMethodMessagingElement;
  exports.PaymentRequestButtonElement = PaymentRequestButtonElement;
  exports.ShippingAddressElement = ShippingAddressElement;
  exports.useCartElement = useCartElement;
  exports.useCartElementState = useCartElementState;
  exports.useElements = useElements;
  exports.useStripe = useStripe;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/@stripe/stripe-js/dist/pure.js":
/*!*****************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/pure.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var V3_URL = 'https://js.stripe.com/v3';
var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
var EXISTING_SCRIPT_MESSAGE = 'loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used';
var findScript = function findScript() {
  var scripts = document.querySelectorAll("script[src^=\"".concat(V3_URL, "\"]"));

  for (var i = 0; i < scripts.length; i++) {
    var script = scripts[i];

    if (!V3_URL_REGEX.test(script.src)) {
      continue;
    }

    return script;
  }

  return null;
};

var injectScript = function injectScript(params) {
  var queryString = params && !params.advancedFraudSignals ? '?advancedFraudSignals=false' : '';
  var script = document.createElement('script');
  script.src = "".concat(V3_URL).concat(queryString);
  var headOrBody = document.head || document.body;

  if (!headOrBody) {
    throw new Error('Expected document.body not to be null. Stripe.js requires a <body> element.');
  }

  headOrBody.appendChild(script);
  return script;
};

var registerWrapper = function registerWrapper(stripe, startTime) {
  if (!stripe || !stripe._registerWrapper) {
    return;
  }

  stripe._registerWrapper({
    name: 'stripe-js',
    version: "1.54.1",
    startTime: startTime
  });
};

var stripePromise = null;
var loadScript = function loadScript(params) {
  // Ensure that we only attempt to load Stripe.js at most once
  if (stripePromise !== null) {
    return stripePromise;
  }

  stripePromise = new Promise(function (resolve, reject) {
    if (typeof window === 'undefined' || typeof document === 'undefined') {
      // Resolve to null when imported server side. This makes the module
      // safe to import in an isomorphic code base.
      resolve(null);
      return;
    }

    if (window.Stripe && params) {
      console.warn(EXISTING_SCRIPT_MESSAGE);
    }

    if (window.Stripe) {
      resolve(window.Stripe);
      return;
    }

    try {
      var script = findScript();

      if (script && params) {
        console.warn(EXISTING_SCRIPT_MESSAGE);
      } else if (!script) {
        script = injectScript(params);
      }

      script.addEventListener('load', function () {
        if (window.Stripe) {
          resolve(window.Stripe);
        } else {
          reject(new Error('Stripe.js not available'));
        }
      });
      script.addEventListener('error', function () {
        reject(new Error('Failed to load Stripe.js'));
      });
    } catch (error) {
      reject(error);
      return;
    }
  });
  return stripePromise;
};
var initStripe = function initStripe(maybeStripe, args, startTime) {
  if (maybeStripe === null) {
    return null;
  }

  var stripe = maybeStripe.apply(undefined, args);
  registerWrapper(stripe, startTime);
  return stripe;
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

var validateLoadParams = function validateLoadParams(params) {
  var errorMessage = "invalid load parameters; expected object of shape\n\n    {advancedFraudSignals: boolean}\n\nbut received\n\n    ".concat(JSON.stringify(params), "\n");

  if (params === null || _typeof(params) !== 'object') {
    throw new Error(errorMessage);
  }

  if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === 'boolean') {
    return params;
  }

  throw new Error(errorMessage);
};

var loadParams;
var loadStripeCalled = false;
var loadStripe = function loadStripe() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  loadStripeCalled = true;
  var startTime = Date.now();
  return loadScript(loadParams).then(function (maybeStripe) {
    return initStripe(maybeStripe, args, startTime);
  });
};

loadStripe.setLoadParameters = function (params) {
  // we won't throw an error if setLoadParameters is called with the same values as before
  if (loadStripeCalled && loadParams) {
    var validatedParams = validateLoadParams(params);
    var parameterKeys = Object.keys(validatedParams);
    var sameParameters = parameterKeys.reduce(function (previousValue, currentValue) {
      var _loadParams;

      return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);
    }, true);

    if (sameParameters) {
      return;
    }
  }

  if (loadStripeCalled) {
    throw new Error('You cannot change load parameters after calling loadStripe');
  }

  loadParams = validateLoadParams(params);
};

exports.loadStripe = loadStripe;


/***/ }),

/***/ "./node_modules/@stripe/stripe-js/pure.js":
/*!************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/pure.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./dist/pure.js */ "./node_modules/@stripe/stripe-js/dist/pure.js");


/***/ }),

/***/ "./node_modules/@formspree/react/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@formspree/react/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardElement": () => (/* reexport safe */ _stripe_react_stripe_js__WEBPACK_IMPORTED_MODULE_3__.CardElement),
/* harmony export */   "FormspreeProvider": () => (/* binding */ I),
/* harmony export */   "ValidationError": () => (/* binding */ J),
/* harmony export */   "isFieldError": () => (/* reexport safe */ _formspree_core__WEBPACK_IMPORTED_MODULE_2__.isFieldError),
/* harmony export */   "useForm": () => (/* binding */ q),
/* harmony export */   "useFormspree": () => (/* binding */ S)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _formspree_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @formspree/core */ "./node_modules/@formspree/core/dist/index.js");
/* harmony import */ var _stripe_stripe_js_pure_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stripe/stripe-js/pure.js */ "./node_modules/@stripe/stripe-js/pure.js");
/* harmony import */ var _stripe_react_stripe_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stripe/react-stripe-js */ "./node_modules/@stripe/react-stripe-js/dist/react-stripe.umd.js");
var B=(0,react__WEBPACK_IMPORTED_MODULE_0__.lazy)(()=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @stripe/react-stripe-js */ "./node_modules/@stripe/react-stripe-js/dist/react-stripe.umd.js", 19)).then(r=>({default:r.Elements}))),b=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);b.displayName="Formspree";var x,O=r=>(x||(x=(0,_stripe_stripe_js_pure_js__WEBPACK_IMPORTED_MODULE_1__.loadStripe)(r)),x),D=(r,o)=>{let i={};return r&&(i.stripePromise=r),o&&(i.project=o),(0,_formspree_core__WEBPACK_IMPORTED_MODULE_2__.createClient)(i)},I=r=>{let[o,i]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0),[p,c]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(D(o,r.project));return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>(p.startBrowserSession(),()=>{p.teardown()}),[]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{let a=async u=>{let l=await O(u);l&&i(l)};r.stripePK&&a(r.stripePK)},[r.stripePK]),(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{o&&c(D(o,r.project))},[o]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(b.Provider,{value:{client:p}},r.stripePK?react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,o&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense,{fallback:react__WEBPACK_IMPORTED_MODULE_0__.createElement("p",null,"....")},react__WEBPACK_IMPORTED_MODULE_0__.createElement(B,{stripe:o},react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,r.children)))):react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,r.children))};function S(){return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(b)??{client:(0,_formspree_core__WEBPACK_IMPORTED_MODULE_2__.getDefaultClient)()}}var _="2.4.4";var $=r=>r.preventDefault!==void 0,q=(r,o={})=>{let[i,p]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),[c,a]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[u,l]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1),[j,f]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]),d=S(),T=o.client||d,P,h;if(!T)throw new Error("You must provide a Formspree client");if(!r)throw new Error('You must provide a form key or hashid (e.g. useForm("myForm") or useForm("123xyz")');d.client&&d.client.stripePromise&&(P=(0,_stripe_react_stripe_js__WEBPACK_IMPORTED_MODULE_3__.useStripe)(),h=(0,_stripe_react_stripe_js__WEBPACK_IMPORTED_MODULE_3__.useElements)());let y=!!o.debug,v=o.data;return[{result:i,submitting:c,succeeded:u,errors:j},async g=>{let R=async t=>{t.preventDefault();let s=t.target;if(s.tagName!="FORM")throw new Error("submit was triggered for a non-form element");return new FormData(s)},e=$(g)?await R(g):g,V=(t,s)=>{e instanceof FormData?e.append(t,s):e=Object.assign(e,{[t]:s})};if(typeof v=="object")for(let[t,s]of Object.entries(v)){let m;typeof s=="function"?m=await s():m=s,m!==void 0&&V(t,m)}let M=async()=>{let t={...e.address_line1&&{line1:e.address_line1},...e.address_line2&&{line2:e.address_line2},...e.address_city&&{city:e.address_city},...e.address_country&&{country:e.address_country},...e.address_state&&{state:e.address_state},...e.address_postal_code&&{postal_code:e.address_postal_code}};return await P.createPaymentMethod({type:"card",card:h.getElement(_stripe_react_stripe_js__WEBPACK_IMPORTED_MODULE_3__.CardElement),billing_details:{...e.name&&{name:e.name},...e.email&&{email:e.email},...e.phone&&{phone:e.phone},...t&&{address:t}}})};return a(!0),d.client.submitForm(r,e,{endpoint:o.endpoint,clientName:`@formspree/react@${_}`,createPaymentMethod:d.client&&d.client.stripePromise?M:void 0}).then(t=>{let s=t.response.status,m;return s===200?(y&&console.log("Form submitted",t),l(!0),p(t),f([])):s>=400&&(m=t.body,m.errors?(f(m.errors),y&&console.log("Error",t)):(f([{message:"Unexpected error"}]),y&&console.log("Unexpected error",t)),l(!1)),t}).catch(t=>{throw y&&console.log("Unexpected error",t),l(!1),t}).finally(()=>{a(!1)})},()=>{a(!1),l(!1),f([])}]};var J=r=>{let{prefix:o,field:i,errors:p,...c}=r,a=(p||[]).find(u=>u.field===i);return a?react__WEBPACK_IMPORTED_MODULE_0__.createElement("div",{...c},o," ",a.message):null};


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_formspree_react_dist_index_mjs.bundle.js.map